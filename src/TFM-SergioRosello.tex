%----------
%   WARNING
%----------

% This Guide contains Library recommendations based mainly on APA and IEEE styles, but you must always follow the guidelines of your TFG Tutor and the TFG regulations for your degree.

% THIS TEMPLATE IS BASED ON THE APA STYLE 


%----------
% DOCUMENT SETTINGS
%----------

\documentclass[12pt]{report} % font: 12pt

% margins: 2.5 cm top and bottom; 3 cm left and right
\usepackage[
a4paper,
vmargin=2.5cm,
hmargin=3cm
]{geometry}

% Paragraph Spacing and Line Spacing: Narrow (6 pt / 1.15 spacing) or Moderate (6 pt / 1.5 spacing)
\renewcommand{\baselinestretch}{1.15}
\parskip=6pt

% Color settings for cover and code listings 
\usepackage[table]{xcolor}
\definecolor{azulUC3M}{RGB}{0,0,102}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

% In the template we include the file OUTPUT.XMPDATA. You can download that file and include the metadata that will be incorporated into the PDF file when you compile the memoria.tex file. Then upload it back to your project. 
% Commented out due to upstream error
% \use package[a-1b]{pdf}

% LINKS
\usepackage{hyperref}
\hypersetup{colorlinks=true,
	linkcolor=black, % links to parts of the document (e.g. index) in black
	urlcolor=blue} % links to resources outside the document in blue

% MATH EXPRESSIONS
\usepackage{amsmath,amssymb,amsfonts,amsthm}

% Character encoding
\usepackage{txfonts} 
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% English settings
\usepackage[spanish]{babel} 
\usepackage[babel, spanish=spanish]{csquotes}
\AtBeginEnvironment{quote}{\small}

% Footer settings
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\rfoot{\thepage}
\fancypagestyle{plain}{\pagestyle{fancy}}

% DESIGN OF THE TITLES of the parts of the work (chapters and epigraphs or sub-chapters)
\usepackage{titlesec}
\usepackage{titletoc}
\titleformat{\chapter}[block]
{\large\bfseries\filcenter}
{\thechapter.}
{5pt}
{\MakeUppercase}
{}
\titlespacing{\chapter}{0pt}{0pt}{*3}
\titlecontents{chapter}
[0pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace\uppercase}
{\contentsmargin{0pt}\uppercase}                        
{\titlerule*[.7pc]{.}\contentspage}                 

\titleformat{\section}
{\bfseries}
{\thesection.}
{5pt}
{}
\titlecontents{section}
[5pt]                                               
{}
{\contentsmargin{0pt}\thecontentslabel.\enspace}
{\contentsmargin{0pt}}
{\titlerule*[.7pc]{.}\contentspage}

\titleformat{\subsection}
{\normalsize\bfseries}
{\thesubsection.}
{5pt}
{}
\titlecontents{subsection}
[10pt]                                               
{}
{\contentsmargin{0pt}                          
	\thecontentslabel.\enspace}
{\contentsmargin{0pt}}                        
{\titlerule*[.7pc]{.}\contentspage}  


% Tables and figures settings
\usepackage{multirow} % combine cells 
\usepackage{caption} % customize the title of tables and figures
\usepackage{floatrow} % we use this package and its \ ttabbox and \ ffigbox macros to align the table and figure names according to the defined style.
\usepackage{array} % with this package we can define in the following line a new type of column for tables: custom width and centered content
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
\DeclareCaptionFormat{upper}{#1#2\uppercase{#3}\par}
\usepackage{graphicx}
\graphicspath{{../imagenes/}} % images folder

% Table layout for social sciences and humanities
\captionsetup*[table]{
	justification=raggedright,
	labelsep=newline,
	labelfont=small,
	singlelinecheck=false,
	labelfont=bf,
	font=small,
	textfont=it
}

% Figure layout for social sciences and humanities
\captionsetup[figure]{
	%name=Figura,
	singlelinecheck=off,
	labelsep=newline,
	font=small,
	labelfont=bf,
	textfont=it
}
\floatsetup[figure]{
    style=plaintop,
    heightadjust=caption,
    footposition=bottom,
    font=small
}

% Figures and tables footnote layout 
\captionsetup*[floatfoot]{
    footfont={small, up}
}

% FOOTNOTES
\usepackage{chngcntr} % continuous numbering of footnotes
\counterwithout{footnote}{chapter}

% CODE LISTINGS 
% support and styling for listings. More information in  https://es.wikibooks.org/wiki/Manual_de_LaTeX/Listados_de_código/Listados_con_listings
\usepackage{listings}

% Custom listing
\lstdefinestyle{estilo}{ frame=Ltb,
	framerule=0pt,
	aboveskip=0.5cm,
	framextopmargin=3pt,
	framexbottommargin=3pt,
	framexleftmargin=0.4cm,
	framesep=0pt,
	rulesep=.4pt,
	backgroundcolor=\color{gray97},
	rulesepcolor=\color{black},
	%
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\bfseries,
	stringstyle=\ttfamily,
	showstringspaces = false,
	commentstyle=\color{gray45},     
	%
	numbers=left,
	numbersep=15pt,
	numberstyle=\tiny,
	numberfirstline = false,
	breaklines=true,
	xleftmargin=\parindent
}

\captionsetup*[lstlisting]{font=small, labelsep=period}
 
\lstset{style=estilo}
\renewcommand{\lstlistingname}{\uppercase{Código}}


% REFERENCES 

% APA bibliography setup
\usepackage[style=apa, backend=biber, natbib=true, hyperref=true, uniquelist=false, sortcites]{biblatex}

\addbibresource{referencias.bib} % The references.bib file in which the bibliography used should be

% Caption package, for use of subfigures.
\usepackage{subfig}


%-------------
%	DOCUMENT
%-------------

\begin{document}

\pagenumbering{roman} % Roman numerals are used in the numbering of the pages preceding the body of the work.
	
\include{cover}

\include{abstract}

\include{dedication}

\include{toc}

\include{figures}

\include{tables}

%----------
%	THESIS
%----------	
\clearpage
\pagenumbering{arabic} % numbering with Arabic numerals for the rest of the document.	

\chapter{Estado del arte}

\section{Evolución del desarrollo de software, desde su concepción hasta la actualidad}

El software solo es posible gracias al hardware en el que se ejecuta.
Naturalmente, este campo ha adoptado las costumbres y características del mundo del Hardware.

Inicialmente, en 1950, actualizar el software de un ordenador suponía un gasto tremendo, ya que el software que corría el ordenador estaba estrictamente acoplado al hardware que hacia posible dicha ejecución.

Al no disponer de una conexión a Internet y requerir la presencia de ingenieros enviados por parte de la compañía que fabrica el propio ordenador, las empresas que poseían un ordenador, no esperaban tener que actualizar su software regularmente.

A medida que se avanzaba en la fabricación de ordenadores personales y se estandarizaba Internet, los requisitos para poder actualizar el software del ordenador empezaban a ofrecer menos resistencia.

A medida que evoluciona Internet, también lo hacen las aplicaciones que se alojan en el, pasamos de Internet 1.0, a  Internet 2.0, en el que las paginas web dejan de ser portales de visita, como revistas, y se empieza a poder diferenciar clientes, y adaptar el funcionamiento de la pagina al cliente especifico.

Estos nuevos requisitos, incorporan nueva complejidad a la ya creciente complejidad del software, como por ejemplo, cualquier pagina que tenga que poder diferenciar a sus clientes, por lógica de negocio, debe añadir a su pila de componentes, una base de datos.

Debido a esta creciente complejidad, las empresas cuyo modelo de negocio estaba basado en el software, ofrecían actualizaciones muy poco regularmente ya que el proceso de construcción y compilación de dicho software era tedioso.
Como añadido, a mayor complejidad de aplicación, mayor era el tiempo que se tenia que designar a la compilación de las distintas piezas que componían el software. (Base de datos, Portal frontal, Sistema de lógica interna, entre otras.)

Debido a la complejidad de las aplicaciones generadas, el proceso de Despliegue, ha sido, y sigue siendo, uno de los puntos de estrés de muchas empresas.

La realidad, es que desde 1957, en el que se pretendía desarrollar iterativamente e incrementalmente \cite{IID}, se ha estado pensando colectivamente en como mejorar el desarrollo de software, desde su fase de concepción, a su fase de despliegue, pero hasta 2001, no se escribió el manifesto del desarrollo ágil \cite{agile}, en el que se destacan los pilares fundamentales sobre los que se ha construido la filosofía DevOps \cite{CD-TF}, posteriormente extendida a la filosofía DevSecOps.

Esto último es lo que se va a proceder a analizar en este trabajo.


\subsection{Historia de los despliegues}

En esta sección analizaremos las distintas formas en las que se ha desarrollado software comúnmente, hasta hoy en día, haciendo énfasis en el desarrollo ágil, y el uso de Pipelines para garantizar cierta calidad del software antes de desplegar.

\subsubsection{1950}

En esta década, se empieza a pensar y desarrollar una mejor forma de construir software. \par
El proyecto más memorable en el que se hace uso de técnicas modernas de desarrollo de software es "Project Mercury". \par
Este proyecto, centrado en poner al hombre a la luna, requería de una capacidad de construcción de software ejemplar.
Gerald M. Weinberg fue el arquitecto del proyecto.
Decidieron que ``el desarrollo en cascada aplicado a un proyecto grande era bastante estúpido, o al menos, ignorante a la realidad'' \cite{GW-PM} y desarrollaron software con una metodología similar a la estipulada por XP.

\subsubsection{1968}

La primera aparición formal de desarrollo iterativo aparece en un documento interno de IBM en el que se describe que primero se define formalmente la funcionalidad, posteriormente se establecen unos tests, y se empieza a desarrollar, a medida que avanza el proceso, se crean nuevos tests, mas específicos, al final, el sistema, se convierte en la aplicación. \cite{ID-FB}

\subsubsection{1970}

Se documenta por primera vez el desarrollo en cascada en el articulo que escribe el Dr. Winston W. Royce. \par
Como curiosidad, Royce aconseja realizar el proceso de desarrollo compuesto por las fases de análisis de requisitos, construcción del software, testeo y despliegue dos veces, pero a medida que se ha extendido esta metodología, se ha popularizado siguiendo únicamente una de estas iteraciones, quedando en el desarrollo en cascada que se conoce hoy en día. \cite{royce1970} \par
Actualmente, una de las metodologías de desarrollo más populares, debido a su simplicidad, y sentido. \par

\subsubsection{1975}

Vic Basil y Joe Turner escriben un articulo explicando como desarrollaron una serie de compiladores extendidos para una familia de lenguajes de programación específicos a dominio.
En este articulo, se describe claramente el desarrollo iterativo incremental (IID). \cite{6312870}

Durante los años 70, el desarrollo en cascada cobra una popularidad abismal, tanta, que los lideres de equipo encargados de proyectos tan importantes como la creación del software de la lanzadera espacial de la NASA, sentían la obligación de justificar por que no habían usado el método de de desarrollo en cascada.
La justificación mas común para no usar el desarrollo en cascada, era que los requisitos del proyecto cambiaban continuamente, y no podían ajustar el desarrollo en cascada a estos cambios.

\subsubsection{1980}

Durante los años 80, muchos desarrolladores prominentes publican artículos sobre como el desarrollo en cascada no es una buena forma de construir un proyecto medianamente grande de software.
Parafraseando el articulo titulado ``Un proceso de diseño racional: Como y por que falsearlo'' \cite{Parnas1986}
\begin{itemize}
  \item{Un usuario raramente sabe exactamente todo lo que quiere y no puede expresar todo lo que sabe}
  \item{Existen muchos detalles de implementación que no se pueden anticipar, aunque tengamos todos los requisitos claros}
  \item{Aunque sepamos todos los detalles, como humanos, no podemos procesar tanta complejidad}
  \item{Aunque pudiésemos procesar toda esta complejidad, existen fuerzas exteriores, que hacen que cambien los requisitos o invaliden decisiones previas}
\end{itemize}
Estas razones encabezan la lista de motivos por los que la tendencia a la hora de desarrollar software debía de virar hacia el desarrollo incremental e iterativo.

\subsubsection{1990 - Presente}

A medida que el desarrollo en cascada demostraba que no era lo suficientemente flexible para llevar a cabo proyectos medianamente grandes, cantidad de nuevos artículos aparecían con nuevas y mejoradas técnicas de desarrollo iterativo e incremental. \par
Muchas de estas siguen aplicándose hoy en día, como XP (Extreme Programming), Dynamic Systems Development Method (DSDM), Scrum y FDD (Feature Driven Development), entre otras. \par
El 1 de febrero de 2001, se celebra una reunion entre varios expertos en procesos, entre ellos, los promotores de XP, Scrum, FDD. 
En ese momento se forma la alianza ágil (agile alliance), cuya función es promover métodos de desarrollo de software iterativo e incremental. \par

\section{Desarrollo ágil}

A medida que nos adentramos en la actualidad, podemos observar como el uso de la metodología ágil aumenta en popularidad \cite{Hoda2018}.
Actualmente, el 95\% de las empresas dicen desarrollar software siguiendo la metodología ágil. \cite{stateofagile}

\subsection{Que es el desarrollo ágil}

El termino ``Desarrollo Ágil'' se acuñó en 2001, en una reunion que celebraron distintos representares de alternativas al popular desarrollo en cascada.
En esta reunion, asistieron representares de técnicas de desarrollo como Extreme Programming, SCRUM, DSDM, Adaptive Software Development, Crystal, Feature-Driven Development, Pragmatic Programming y otros simpatizantes.
La finalidad era asentar unas bases sobre las que todos estuviesen de acuerdo.

Al terminar, se acuñó el término desarrollo ágil.

Los principales valores del desarrollo ágil son los siguientes: \cite{agilePrinciples}

\begin{itemize}
  \item{Nuestra mayor prioridad es satisfacer al cliente mediante la entrega temprana y continua de software con valor.}
  \item{Aceptamos que los requisitos cambien, incluso en etapas tardías del desarrollo. Los procesos Ágiles aprovechan el cambio para proporcionar ventaja competitiva al cliente.}
  \item{Entregamos software funcional frecuentemente, entre dos semanas y dos meses, con preferencia al periodo de tiempo más corto posible.}
  \item{Los responsables de negocio y los desarrolladores trabajamos juntos de forma cotidiana durante todo el proyecto.}
  \item{Los proyectos se desarrollan en torno a individuos motivados. Hay que darles el entorno y el apoyo que necesitan, y confiarles la ejecución del trabajo.}
  \item{El método más eficiente y efectivo de comunicar información al equipo de desarrollo y entre sus miembros es la conversación cara a cara.}
  \item{El software funcionando es la medida principal de progreso.}
  \item{Los procesos Ágiles promueven el desarrollo sostenible. Los promotores, desarrolladores y usuarios debemos ser capaces de mantener un ritmo constante de forma indefinida.}
  \item{La atención continua a la excelencia técnica y al buen diseño mejora la Agilidad.}
  \item{La simplicidad, o el arte de maximizar la cantidad de trabajo no realizado, es esencial.}
  \item{Las mejores arquitecturas, requisitos y diseños emergen de equipos auto-organizados.}
  \item{A intervalos regulares el equipo reflexiona sobre cómo ser más efectivo para a continuación ajustar y perfeccionar su comportamiento en consecuencia.}
\end{itemize}

\subsection{Como llevar a cabo el desarrollo ágil}

Una vez repasados los valores del desarrollo ágil, debemos ahondar más en como repercuten estos en el día a día de un proyecto de software que usa la metodología ágil.

Cada uno de los pasos descritos a continuación forma parte de una iteración dentro del proceso de desarrollo de software.
Estas fases, van construyendo sobre las previas, hasta que se completa la aplicación.

\subsubsection{Firma del contrato}

Al inicio de la colaboración, se tiene una reunion, en la que el cliente y la empresa trabajan conjuntamente para asentar las bases sobre las que se construirá el proyecto.
Este tipo de enfoque se llama ``top-down approach'' %TODO: Cite needed

\subsubsection{tests de aceptación}

Una vez establecidas ciertas bases, se empiezan a definir funcionalidades, casos de uso.
Aquí es donde entran en juego técnicas de verificación de los casos de uso.
Se generan documentos ejecutables que consisten en asentar los requisitos básicos para que un usuario realize una acción y llegue a un resultado final esperado, dadas unas pre condiciones.
Estos tests, se llaman comúnmente tests de aceptación, y se encargan de verificar que el software realizado por la empresa cumple con los requisitos impuestos por el cliente.

El desarrollador puede saber cuando ha acabado de implementar el ``happy path'' de su parte del código cuando su trabajo pasa todos los tests de aceptación que se han definido con anterioridad.
La ventaja que tienen estos tests frente al resto de tests que se usan de desarrollo ágil, es que estos tests están diseñados para que cualquier persona, sea desarrollador, o no, los pueda definir, crear, y editar.
De esta forma, el desarrollo se mantiene ágil iteración tras iteración, ya que en caso de haber un cambio entre iteraciones, únicamente se tienen que ejecutar los tests de aceptación para saber si la version actual del software cumple con los nuevos requisitos.

La sintaxis estándar de los tests de aceptación es la siguiente:

\begin{lstlisting}
Feature: Registro de usuario

  Background:
    Given la base de datos esta actualizada

  Scenario: Usuario existente inicia sesion
    Given ya tengo cuenta en la aplicacion
    When introduzco mis credenciales correctamente
    Then inicio sesion en la aplicacion
\end{lstlisting}

De esta forma, se definen las características (``Features'') del producto a construir.
Cada característica engloba una serie de ``caminos felices'' que puede seguir el usuario.
La concatenación de acciones que sigue el usuario para llegar a un estado final se llama ``camino feliz'' (``Scenario'').
Dentro de cada camino feliz, existen una serie de acciones, representadas por ``Given, When y Then''.

\begin{itemize}
  \item{``Given'' representa el estado inicial en el que debe estar la aplicación}
  \item{``When'' representa la acción a ejecutar}
  \item{``Then'' representa el estado final en el que debe quedar la aplicación.}
\end{itemize}

Este estilo, o formato de escritura se denomina ``Gherkin'' y es fundamental en la vertiente BDD de desarrollo ágil.

\subsubsection{Desarrollo y testeo del código}

Una vez se ha definido la especificación, los programadores, pueden empezar con el desarrollo.
Esto asegura que todo el mundo trabaja en sincronía, desde los clientes, al analista, al jefe de proyecto, al desarrollador.
La existencia de estos tests hace que cualquier persona involucrada en el proyecto que quiera revisar la documentación se dirija al mismo sitio.
Esto obliga a que esta documentación viviente, se mantenga actualizada y al día, entre iteraciones.

A medida que los programadores ahondan en complejidad de desarrollo, se encuentran con una complejidad cada vez mayor.
Siguiendo con el ejemplo anterior, del inicio de sesion, se tienen que definir casos mas específicos, como la forma en la que se conecta la plataforma a la base de datos, el mensaje de error que aparece cuando el nombre de usuario es incorrecto, y cuando la contraseña es incorrecta, entre muchos otros.
Para asegurar el correcto funcionamiento de su código, los desarrolladores deben crear tests para cubrir cualquier cauce que pueda tomar su código.
De esta forma, pueden delegar la comprobación de su código a los tests, que van a verificar que la lógica que están programando es la adecuada, definida previamente.
Una vez se hayan ejecutado los tests, el programador puede estar seguro de que ha implementado correctamente el código que se le ha solicitado crear.

Existe un nivel mas detallado de tests.
Estos se llaman tests unitarios.
Su función es validar el correcto funcionamiento de los componentes específicos (Funciones, clases, datos) y la forma  que tienen de alterar o crear los datos necesarios, que, en combinación unos con otros, habilitan la creación de la lógica de la aplicación.

\subsubsection{Despliegue del código}

Una vez los desarrolladores han terminado la tarea, y el proyecto cumple con las especificaciones descritas por el cliente, es hora de desplegar el código a producción.

Al centrarse principalmente en la fase de desarrollo de software, los equipos que siguen las recomendaciones estipuladas por la metodología ágil, frecuentemente olvidan la importancia del despliegue en el flujo de desarrollo del software y el despliegue, deja de ser parte del proceso iterativo, sino que, al terminar el desarrollo, se despliega el código a producción.

Esta ha sido el modus operandi de la mayoría de equipos que han seguido el desarrollo ágil.

Esto desemboca en tremendos dolores de cabeza que pueden llegar a prolongarse durante horas para pasar el código desarrollado en los equipos internos de la empresa a los equipos destinados para alojar el código en producción o que directamente pueden llevar a una empresa a la bancarrota en cuestión de minutos. \cite{seven2014}

\section{De desarrollo ágil, a DevOps}

Para llevar a cabo cualquier tipo de proyecto, deben haber como mínimo dos partes implicadas.
El cliente y la empresa que va a llevar a cabo la vision del cliente.\par
Estas dos partes pueden ser tan complejas o simples como se quiera, pero deben existir.
Desde un proyecto llevado a cabo únicamente por una persona a un proyecto distribuido separado entre distintas zonas horarias.

La mayor de las responsabilidades del \textbf{cliente} es especificar claramente los requisitos del producto o idea que tiene en mente.

La responsabilidad de \textbf{la empresa} es de desarrollar el producto que tiene el ciente en mente lo mas fielmente posible.

La clave del éxito del desarrollo ágil, basado en iteraciones incrementales, es que establece canales de comunicación directos, estrechos e iterativos entre el cliente y la empresa.
(Existen modelos de desarrollo ágil, en el que se recomienda que el cliente comparta habitación con la empresa que esta desarrollando su producto)

Aunque, como ya se ha demostrado en empresas no directamente relacionadas con el mundo del Software como Canon, Honda, o NEC, entre otras, se puede aplicar el desarrollo ágil a cualquier sector \cite{Hirotaka1986}.
En el mundo del software, podemos hacer uso de herramientas automatizadas y frameworks para satisfacer los principales valores del desarrollo ágil.
De esta forma, se logra crear un proyecto que se mantiene actualizado entre las especificaciones y el desarrollo.

En 2006, se escribe públicamente por primera vez sobre este proceso, en el articulo llamado ``The Deployment Production Line'' en el que se describe como construir una cadena de montaje, en la que el código puede ser desplegado a producción sencillamente presionando un botón, y revertido, en caso de que algo fuera mal de igual manera. \cite{10.1109/AGILE.2006.53}

\subsection{Que es DevOps}


La filosofía DevOps nace como respuesta a una falta de comunicación, y creciente frustración entre equipos dentro de un mismo desarrollo.

Su finalidad es establecer una comunicación constante entre las distintas fases y equipos de desarrollo, mayoritariamente entre los desarrolladores y los equipos de operaciones, que se encargan de poner el código que genera el equipo de desarrolladores a un entorno de producción. Esto no quiere decir que se excluyan a cualquier otro equipo involucrado en el desarrollo del software, como el de QA.

El fenómeno DevOps se puede considerar una extension del desarrollo ágil, debido a que, en su forma mas reducida, acorta las iteraciones del desarrollo de una fecha especifica, a un commit especifico. \cite{dobra2018}
Cada commit pasa por una serie de comprobaciones, (Pipeline) para verificar que efectivamente el código que añade a producción es adecuado para ser desplegado.

Otras de las prioridades de la cultura DevOps es Habilitar la automatización sobre la documentación, presentar al desarrollador posibilidades (API de testeo de código), en vez de impedimentos (procesos)

Como consecuencia, se crea un flujo automatizado de Integración Continua y Despliegue Continuo del código generado iterativamente a lo largo de todo el proyecto.

La filosofía DevOps en la construcción y despliegue de software, por tanto gira en torno a establecer una serie de procesos y comprobaciones por los que tiene que pasar cada desarrollo candidato a se desplegado a producción. 

Desde la concepción del proyecto, antes de desarrollar el código, se establecen los pasos mínimos por los que tiene que pasar cada candidato a producción (Commit) creando así un Pipeline, que es la union de esos pasos automatizados, de forma que, para que el candidato a producción llegue a producción, siempre tenga que pasar por estos mismos pasos y comprobaciones.
Ya sea un apaño en producción, como un desarrollo nuevo.

En la metodología ágil, el desarrollo de una nueva funcionalidad se hace de forma iterativa e incremental, empezando primero por los tests.
En el enfoque de la filosofía DevOps, la creación del Pipeline se añade anteriormente a los tests, para que, una vez se este desarrollando, se puedan revisar los desarrollos directamente con los tests, de forma automática en el Pipeline una vez se cumplen una serie de acciones, normalmente, un commit.

Al igual que en el desarrollo ágil, el desarrollo del Pipeline es siempre constante, este también va creciendo de forma iterativa e incremental, añadiendo más tests, más pasos, y por tanto revisando y asegurando mayor confianza en el commit que pasa todo el pipeline.

En esencia, se trata de un desarrollo mas, pero en vez de que su función sea cumplir un requisito del cliente, su función es asegurar la estabilidad y calidad del software. 

``Cada vez que se añade un cambio al servidor de control de versiones, se espera que pase todos los tests, produzca código funcional y se pueda desplegar a producción.
Esta es la suposición inicial.
La tarea de un sistema de integración continua es la de refutar dicha suposición, demostrando que este candidato a producción no es adecuado para entrar a producción''\cite{Humble2010}


\subsection{La seguridad en la metodología ágil}

\subsection{Historia Inicio del fenómeno DevSecOps}

\section{presente como se gestiona la seguridad en el mundo DevSecOps}

\section{Empresas actuales, casos de éxito}

\begin{itemize}
  \item{IBM}
  \item{Netflix}
  \item{Amazon}
\end{itemize}

\subsection{Presente Aplicaciones Off the Shelf}

\begin{itemize}
  \item{Larch Darkly}
\end{itemize}


\include{bibliography}

%----------
%	Appendix
%----------	

% If your work includes Appendix, you can uncomment the following lines
%\chapter* {Appendix x}
%\pagenumbering{gobble} % Appendix pages are not numbered

\end{document}
